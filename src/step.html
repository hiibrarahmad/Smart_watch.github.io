<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>3D Model Viewer</title>
    <style>
      html, body { margin:0; padding:0; height:100%; overflow:hidden; }
      #viewer { width:100%; height:100%; background:#9b9494; position:relative; }
      #viewer canvas { display:block; width:100%; height:100%; }
      #ui { position:absolute; top:20px; right:20px; display:flex; gap:0.5em; z-index:15; }
      .btn { background:rgba(0,0,0,0.6); color:#fff; border:none; padding:.4em .8em; border-radius:4px; cursor:pointer; }
      .btn:hover { background:rgba(0,0,0,0.8); }
    </style>
    <script src="./dist/js-3d-model-viewer.js"></script>
  </head>
  <body>
    <div id="viewer"></div>
    <div id="ui">
      <button id="fsBtn" class="btn">â¤¢ Fullscreen</button>
      <button id="explodeBtn" class="btn">ðŸ’¥ Explode</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
      const viewer    = document.getElementById('viewer');
      const fsBtn     = document.getElementById('fsBtn');
      const explodeBtn= document.getElementById('explodeBtn');
      const meshInfos = [];
      let exploded    = false;

      // 1) Prepare the scene (your existing options)
      const scene = Js3dModelViewer.prepareScene(viewer, {
        grid:true, axesHelper:true, fog:{color:'#9b9494',near:5,far:30},
        background:'#D3D3D3',
        camera:{position:[0,2,6],fov:50, near:0.1,far:1000},
        lights:[
          {type:'ambient',color:'#fff',intensity:0.4},
          {type:'directional',color:'#fff',intensity:0.8,position:[5,10,5]}
        ],
        controls:{enableDamping:true,dampingFactor:0.07,rotateSpeed:0.5,zoomSpeed:1.2}
      });

      // 2) Your exact file lines (unchanged)
      const objUrl = '/src/assets/sample_02.obj';
      const mtlUrl = '/src/assets/sample_02.mtl';
      console.log('ðŸ“¡ fetching:', objUrl, mtlUrl);

      // 3) Load WITHOUT passing an optionsâ€objectâ€”just scene, URLs, onLoad, onError
      Js3dModelViewer.loadObject(
        scene,
        objUrl,
        mtlUrl,

        // onLoad(root):
        (root) => {
          console.log('âœ… Model loaded', root);
          root.traverse(child => {
            if (child.isMesh) {
              meshInfos.push({
                mesh: child,
                originalPos: child.position.clone()
              });
            }
          });
          if (!meshInfos.length) console.warn('No meshes found to explode!');
        },

        // onError(err):
        (err) => {
          console.error('âŒ Load error:', err);
        }
      );

      // 4) Fullscreen toggle, with exit support & prefix fallbacks
      fsBtn.addEventListener('click', () => {
        if (!document.fullscreenElement &&
            !document.webkitFullscreenElement) {
          const req = viewer.requestFullscreen
                   || viewer.webkitRequestFullscreen;
          req.call(viewer);
          fsBtn.textContent = 'â¤¢ Exit Fullscreen';
        } else {
          const exit = document.exitFullscreen
                     || document.webkitExitFullscreen;
          exit.call(document);
          fsBtn.textContent = 'â¤¢ Fullscreen';
        }
      });

      // 5) Explode/reset toggle
      explodeBtn.addEventListener('click', () => {
        if (!meshInfos.length) return;  // nothing to do
        exploded = !exploded;
        explodeBtn.textContent = exploded ? 'ðŸ”§ Reset' : 'ðŸ’¥ Explode';
        meshInfos.forEach(({mesh, originalPos}) => {
          if (exploded) {
            // push each mesh outwards
            const worldPos = mesh.getWorldPosition(new window.THREE.Vector3());
            const dir = worldPos.clone().normalize();
            mesh.position.copy(
              originalPos.clone().add(dir.multiplyScalar(1.5))
            );
          } else {
            // reset to original
            mesh.position.copy(originalPos);
          }
        });
      });
    });
    </script>
  </body>
</html>
